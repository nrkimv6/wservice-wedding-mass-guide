# 병렬 버그 진단

버그 발생 시 **코드 변경 전에** 4개의 병렬 조사 에이전트를 실행하여
근본 원인을 증거 기반으로 파악합니다.

## 트리거

- "버그", "오류 원인", "왜 안 되지", "debug", "병렬 디버그", "원인 찾아줘"

## ⚠️ 핵심 원칙

**코드를 수정하기 전에 반드시 4개 Task 결과를 모두 수집해야 한다.**
추측으로 먼저 수정하지 않는다.

## 실행 단계

### 1단계: 버그 정보 수집

사용자에게 확인:
- 증상 (어떤 동작이 예상과 다른가)
- 에러 메시지 (있다면 전체 스택 트레이스)
- 마지막으로 정상 작동한 시점 (알고 있다면)
- 관련 기능명 또는 파일명 힌트

### 2단계: 4개 Task 에이전트 병렬 실행

아래 4개를 **동시에** Task(Explore) 에이전트로 실행한다.

**Task 1 — 백엔드 코드 경로 추적**
```
{기능명}과 관련된 Python 백엔드 코드를 추적한다.
1. 관련 라우트/서비스/모델 파일을 찾아 읽는다
2. 데이터 흐름을 DB → Service → Route 순서로 설명한다
3. 버그 증상({증상})과 연관될 수 있는 코드 라인을 구체적으로 지목한다
4. 추측이 아닌 코드에서 직접 확인한 내용만 보고한다
```

**Task 2 — 프론트엔드 상태 확인**
```
{기능명}을 렌더링하는 Svelte 컴포넌트와 상태 관리를 확인한다.
1. 관련 .svelte 파일과 store를 찾아 읽는다
2. API 호출 방식과 응답 처리 로직을 확인한다
3. 버그 증상({증상})과 연관될 수 있는 반응성(reactivity) 이슈를 지목한다
4. 추측이 아닌 코드에서 직접 확인한 내용만 보고한다
```

**Task 3 — Git 최근 변경 분석**
```
git log로 최근 변경사항 중 회귀 후보를 식별한다.
1. git log --oneline -20 실행
2. git diff HEAD~5 실행
3. {기능명} 또는 관련 파일을 수정한 커밋을 찾는다
4. 버그 증상({증상})이 시작된 시점과 겹치는 커밋을 후보로 제시한다
```

**Task 4 — 테스트 실행 결과**
```
{기능명} 관련 테스트를 실행하고 결과를 보고한다.
1. 관련 테스트 파일을 찾는다 (tests/ 디렉토리)
2. python -m pytest {관련 테스트 경로} -v --timeout=30 실행
3. pass/fail 목록과 실패 이유를 보고한다
4. 테스트가 없으면 "테스트 없음"으로 보고한다
```

### 3단계: 근본 원인 분석 종합

4개 Task 결과를 취합하여:

1. **가능성 높음 / 낮음** 으로 원인 후보를 분류
2. 각 후보마다 **증거** (파일명:라인번호 또는 커밋 해시)를 명시
3. **신뢰도** (높음/중간/낮음)를 표시
4. 불확실한 사항은 "미확인"으로 표시

### 4단계: 계획서 작성 후 구현

근본 원인이 특정되면:
1. `/plan` 스킬로 수정 계획서 작성
2. 계획서 검토 후 `/implement` 또는 `/next`로 구현

근본 원인이 불분명하면:
- 추가 조사가 필요한 항목을 사용자에게 보고
- 코드 수정 먼저 시도하지 않음

## 출력 형식

```
## 병렬 진단 결과

### Task 1 — 백엔드
{결과 요약}
- 의심 코드: `{파일}:{라인}` — {이유}

### Task 2 — 프론트엔드
{결과 요약}
- 의심 코드: `{파일}:{라인}` — {이유}

### Task 3 — Git 변경
{결과 요약}
- 회귀 후보 커밋: {해시} — {제목}

### Task 4 — 테스트
{pass N / fail M}
- 실패 테스트: {이름} — {이유}

## 근본 원인 분석

| 후보 | 증거 | 신뢰도 |
|------|------|--------|
| {원인 1} | {파일:라인} | 높음 |
| {원인 2} | {커밋 해시} | 중간 |

**결론**: {가장 유력한 원인 한 줄 요약}
```
