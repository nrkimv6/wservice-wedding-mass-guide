---
name: plan
description: "계획 문서 작성. Use when: 계획해, plan, 아이디어, 기획"
---

# 계획 문서 작성

사용자의 아이디어나 요구사항을 계획 문서로 정리하고, **원자 단위 TODO까지 자동 생성**합니다.

## 트리거

- "계획해", "plan", "아이디어", "기획"
- 새로운 기능이나 개선사항을 논의할 때

## 파일 위치

### 프로젝트 경로 해석

**`.claude/projects.json`에서 프로젝트 경로 읽기:**
```powershell
$configPath = "D:\work\project\service\wtools\.claude\projects.json"
$config = Get-Content $configPath | ConvertFrom-Json
# 각 프로젝트의 절대경로: $config.projects[].path
```

**wtools 감지**: 현재 디렉토리에 `common/` 폴더 존재 여부로 판단
- **있으면**: wtools 내부 → `common/docs/plan/`에 공통 계획 저장 + wtools/TODO.md 동기화 **실행**
- **없으면**: 외부 프로젝트 → `{proj.path}/docs/plan/`에 저장 + wtools/TODO.md 동기화 **스킵**

**TODO는 반드시 프로젝트 단위로 생성한다:**

| 대상 | plan 위치 | TODO 위치 |
|------|----------|----------|
| 단일 프로젝트 | `{proj.path}/docs/plan/` | `{proj.path}/docs/plan/` |
| 복수 프로젝트 | `common/docs/plan/` (wtools만) | **각 프로젝트별** `{proj.path}/docs/plan/` |
| 공통 (스킬, 설정 등) | `common/docs/plan/` (wtools만) | `common/docs/plan/` |

파일명: `YYYY-MM-DD_{주제}.md`, 별도 TODO(모드B): `_todo.md` 접미사, 아카이브(모드B): `docs/archive/`로 이동

## 실행 단계

### 1단계: 요구사항 파악

사용자에게 다음을 확인:
- 대상 프로젝트 (없으면 전체 공통)
- 구현하고 싶은 기능/개선사항
- 우선순위 (있다면)

### 2단계: 코드베이스 분석

**반드시 대상 프로젝트의 실제 코드를 읽고** 계획을 세운다:
- 수정 대상 파일의 현재 코드 확인
- 기존 패턴, 컨벤션 파악
- 의존성 및 영향 범위 확인

### 3단계: 계획 문서 작성 + 모드 선택

계획 문서를 작성한 뒤, **분량에 따라 모드를 선택**하고 해당 헬퍼 파일을 읽어 실행한다.

| 모드 | 판단 기준 | 헬퍼 파일 |
|------|----------|----------|
| **모드 A** | 한눈에 읽히는 분량 (Phase 1-2개, 작업 5개 이하) | `_mode-a.md` |
| **모드 B** | 스크롤이 길어지는 분량 (Phase 3개+, 작업 6개+) | `_mode-b.md` |

**실행:** 모드 판단 후, 같은 폴더의 해당 헬퍼 파일을 **Read 도구로 읽고** 지시에 따른다.

### 4단계: wtools/TODO.md 동기화 (wtools만 해당)

**wtools 감지 조건**: 현재 디렉토리에 `common/` 폴더가 있는지 확인
- **있으면**: wtools 내부 → 아래 동기화 실행
- **없으면**: 외부 프로젝트 → 이 단계 **스킵**

1. **wtools/TODO.md를 Read로 연다**
2. **대상 프로젝트 섹션을 찾는다** (없으면 생성)
3. **항목이 이미 있는지 확인한다**
   - 있으면 스킵 (중복 방지)
   - 없으면 Pending에 새 항목 추가: `- [ ] {제목} — [plan 또는 todo]({경로}) (0/N, 0%)`
4. **"마지막 업데이트" 날짜를 오늘로 Edit**
5. **반드시 Edit 완료 후 다시 Read하여 반영을 확인한다** (Read → Edit → Read 패턴)

### 5단계: 최종 검증 (필수)

안내 출력 **전에** 아래 5항목을 Read로 확인. 하나라도 실패 시 해당 단계로 돌아가 수정.

1. **plan 파일 존재** — 모드A: `docs/plan/`, 모드B: `docs/archive/`
2. **TODO 체크박스 존재** — 모드A: plan 내부, 모드B: `_todo.md` 파일
3. **모드B 역참조** — `_todo.md`의 `> 계획:` 링크가 archive를 가리킴
4. **프로젝트 TODO.md** — Pending에 plan 링크 항목 존재
5. **wtools/TODO.md** — 해당 프로젝트 섹션에 항목 + 날짜 오늘

### 6단계: 안내

```
계획 문서 생성 완료

[모드 A]
plan: common/docs/plan/YYYY-MM-DD_{주제}.md (분석 + TODO 포함)

[모드 B]
plan: {archive 경로} (분석용, 아카이브됨)
todo: common/docs/plan/YYYY-MM-DD_{주제}_todo.md (N phases, M tasks)

다음 단계:
- 검토 후 수정이 필요하면 말씀해주세요
- 구현을 시작하려면 "다음" 또는 "구현해"라고 말씀해주세요
```

---

## 🔴 pytest 강제 Phase 규칙 (Python/백엔드 한정)

> **auto-impl은 체크박스만 실행한다. 문서 하단 검증 섹션은 무시될 수 있다.**
> 따라서 모든 TC는 반드시 **TODO Phase 체크박스**로 존재해야 한다.

**대상**: Python 코드를 수정하는 모든 plan. 프론트엔드/PS1은 제외.

### 필수 4-Phase 테스트 구조

구현 Phase 뒤에 반드시 아래 4개 Phase를 **체크박스로** 포함한다.
각 TC는 **개별 체크박스** — 묶어서 하나로 쓰기 금지.

| Phase | 내용 | 포함 조건 |
|-------|------|----------|
| **T1: TC 작성** | RIGHT-BICEP + CORRECT 기반, 함수별 개별 체크박스 | Python 수정 시 항상 |
| **T2: TC 검증 및 수정** | 실행 → passed 확인 → 실패 수정 → 회귀 확인 | Python 수정 시 항상 |
| **T3: E2E 테스트** | mock 기반 end-to-end 흐름 검증 | E2E 존재 시 |
| **T4: HTTP 통합** | `METHOD endpoint` 정상/에러 응답 검증 | API 변경 시 |

**T1 TC 카테고리** (R·B·E 필수, 나머지 해당 시):
- **RIGHT-BICEP**: R(정상), B(경계), I(역), C(교차), E(에러), P(성능)
- **CORRECT**: Co(준수), O(순서), R(범위), Re(참조), E(존재), Ca(기수), T(시간)

**TC 형식**: `- [ ] \`test_{함수명}_{카테고리}_{설명}()\` — {검증 내용}`

**상세 카테고리 설명 및 예시**: `_pytest-reference.md` 참조
**모범 사례**: `quota-stop_todo.md` Phase 4-6

## 원자 작업 기준 (모드 A, B 공통)

| 조건 | 설명 |
|------|------|
| 단일 파일 | 하나의 파일만 수정 (또는 밀접한 2-3개) |
| 명확한 변경 | "무엇을 어떻게 바꾸는지" 한 줄로 설명 가능 |
| 독립 실행 | 같은 Phase 내에서 순서대로 실행하면 됨 |
| 초보 실행 가능 | 코드베이스를 처음 보는 사람도 실행 가능 |

각 원자 작업에 **대상 파일 경로**를 반드시 포함한다.

## 멀티레벨 TODO 구조 (필수)

**모든 TODO는 2레벨 구조로 작성한다:**

```markdown
### Phase N: {Phase 이름}

1. [ ] **{상위 작업}** — 개념적 단위
   - [ ] `{파일경로}`: {구체적 변경 1}
   - [ ] `{파일경로}`: {구체적 변경 2}

2. [ ] **{상위 작업}** — 개념적 단위
   - [ ] `{파일경로}`: {구체적 변경}
```

### 분해 규칙

- **상위**(번호): 기능/개념 단위 → **하위**(대시): 초보 할당 가능한 원자 작업
- **분해 기준**: 파일 2개+, AND 연결, 30분+, 중간 검증 필요 → 하위로 분해
- **하위 원칙**: 한 줄 한 동작 + 파일 경로 필수 + 구체적 내용 + 독립 검증 가능
- **함수 명세** (중간+ 복잡도): 새 함수는 `함수명(파라미터) → 반환값`, 수정은 before/after 요약
- **승격**: 하위 5개 이상이면 별도 Phase로 승격 검토

## 코드블럭 내 체크박스 규칙

**문제**: `/done` 스킬의 체크박스 파싱이 코드블럭/인라인 코드 내 `[ ]`도 미완료로 카운트하여 아카이브 실패

**규칙**: 코드블럭이나 인라인 코드 안에 체크박스 **예시**를 넣을 때는 반드시 유니코드로 치환

| 용도 | 사용 금지 | 사용 필수 |
|------|----------|----------|
| 미완료 예시 | `- [ ]` | `- ☐` (U+2610) |
| 완료 예시 | `- [x]` | `- ☑` (U+2611) 또는 `- [x]` |

**적용 대상**:
- 코드블럭(` ``` `) 안의 TODO/체크박스 예시
- 인라인 코드(`` ` ``) 안의 체크박스 패턴
- 마크다운 테이블 내 예시 코드

**참고**: [2026-02-18_fix-checkbox-in-codeblock.md](../../../common/docs/archive/2026-02-18_fix-checkbox-in-codeblock.md)

## 문서 상태 & 진행률

단일 상태 필드로 plan 문서의 전체 생명주기를 관리한다:

```
초안 → 검토대기 → 검토완료 → 구현중 → 구현완료
         ↘ 수정필요 → 검토대기 (루프)
         ↘ 보류
```

| 상태 | 의미 | 전이 조건 |
|------|------|----------|
| `초안` | /plan 스킬로 최초 작성됨 | plan 작성 시 자동 |
| `검토대기` | 검토 요청 상태 | 사용자가 검토 요청 시 |
| `수정필요` | 검토 후 변경 필요 | 검토자가 피드백 시 |
| `검토완료` | auto-plan(opus) 보완 완료 | auto-plan 완료 시 자동 |
| `구현중` | 구현 착수됨 | /implement 또는 /next 시 자동 |
| `구현완료` | 모든 항목 완료 | /done 시 자동 |
| `보류` | 우선순위 밀림 또는 의존성 대기 | 수동 |

**요약 필드 규칙:**
- 헤더 블록쿼트에 `> 요약: {1-3문장}` 필드를 포함한다
- 이 계획이 왜 필요한지, 핵심 목적을 간결하게 기술
- plan-list 조회 시 테이블에 표시되어 큐 파악에 활용

**진행률 업데이트 규칙:**
- 헤더와 푸터에 `진행률: 완료수/전체 (백분율%)` 표시
- `[x]` 개수를 세어 자동 계산

## 우선순위 기준

| 우선순위 | 기준 |
|:-------:|------|
| P0 | 즉시 실행 가능, 핵심 기능 |
| P1 | 중요하지만 P0 이후 |
| P2 | 있으면 좋은 기능 |
| P3 | 장기 과제 |

## 난이도 기준

| 난이도 | 기준 |
|:-----:|------|
| 낮음 | 1-2시간, 단순 구현 |
| 중간 | 반나절, 여러 파일 수정 |
| 높음 | 하루 이상, 아키텍처 변경 |

## 환경

- **Windows**: 백슬래시(`\`), 절대경로, PowerShell 전용
